using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Xml.Linq;
using System.Xml.Schema;
using System.Xml.Serialization;

namespace Energistics.SchemaGatherer
{
    /// <summary>
    /// Encapsulates methods to generate base data object classes with default .net validation attributes
    /// </summary>
    public static class ValidationExtensions
    {
        private static readonly bool UseCustomTimestamp = bool.Parse(SchemaGatherer.GetAppSetting("INCLUDE_CUSTOM_TIMESTAMP_USAGE"));

        /// <summary>
        /// Generates the data objects with code DOM.
        /// </summary>
        /// <param name="targetFolder">The target folder.</param>
        /// <param name="targetXmlFile">The target XML file specifying the list of top-level schemas to process.</param>
        /// <param name="nameSpace">The name space.</param>
        /// <param name="dataSchemaRootFolder">The root folder for the data schemas.</param>
        /// <param name="standardFamily">The standard family.</param>
        /// <param name="dataSchemaVersion">The data schema version.</param>
        /// <param name="dataObjects">The data objects.</param>
        /// <param name="schemaSubstitutions">The schema substitutions.  The keys are top-level schemas.  The values are included schemas that the top-level schemas are to be substituted for.</param>
        public static void GenerateDataObjectsWithCodeDom(string targetFolder, string targetXmlFile, string nameSpace, string dataSchemaRootFolder, string standardFamily, string dataSchemaVersion, List<string> dataObjects, Dictionary<string, string> schemaSubstitutions)
        {
            var schemas = LoadAndCompileAllSchemas(targetXmlFile, dataSchemaRootFolder, schemaSubstitutions);

            var codeProvider = CodeDomProvider.CreateProvider("CS");
            var codeNamespace = new CodeNamespace(nameSpace);
            var codeCompileUnit = new CodeCompileUnit();

            var outputFile = Path.Combine(targetFolder, "DataObject.cs");
            var options = CodeGenerationOptions.GenerateProperties;
            var version = "2.0.50727.3038";

            var importer = new XmlSchemaImporter(schemas, options, codeProvider, new ImportContext(new CodeIdentifiers(), false));
            var exporter = new XmlCodeExporter(codeNamespace, codeCompileUnit, codeProvider, options, null);

            codeNamespace.Imports.Add(new CodeNamespaceImport(typeof(XmlRootAttribute).Namespace));
            codeCompileUnit.Namespaces.Add(codeNamespace);

            AddNamespaceComments(codeNamespace, version);
            UpdateGeneratedCodeAttribute(exporter, version);

            foreach (XmlSchema schema in schemas)
            {
                ImportXmlSchema(schema, importer, exporter);
            }

            AddValidationAttributes(codeNamespace, schemas, standardFamily, dataSchemaVersion, dataObjects);

            using (var writer = new StreamWriter(outputFile, false, Encoding.UTF8))
            {
                codeProvider.GenerateCodeFromCompileUnit(codeCompileUnit, writer, null);
            }
        }

        private static void AddNamespaceComments(CodeNamespace codeNamespace, string version)
        {
            codeNamespace.Comments.Add(new CodeCommentStatement(""));
            codeNamespace.Comments.Add(new CodeCommentStatement($"This source code was auto-generated by xsd, Version={version}."));
            codeNamespace.Comments.Add(new CodeCommentStatement(""));
        }

        private static void UpdateGeneratedCodeAttribute(XmlCodeExporter exporter, string version)
        {
            var property = exporter.GetType().GetProperty("GeneratedCodeAttribute", BindingFlags.Instance | BindingFlags.NonPublic);
            var attribute = property.GetValue(exporter, null) as CodeAttributeDeclaration;

            attribute.Arguments[0].Value = new CodePrimitiveExpression("xsd");
            attribute.Arguments[1].Value = new CodePrimitiveExpression(version);
        }

        private static void ImportXmlSchema(XmlSchema schema, XmlSchemaImporter importer, XmlCodeExporter exporter)
        {
            foreach (XmlSchemaElement element in schema.Elements.Values)
            {
                exporter.ExportTypeMapping(importer.ImportTypeMapping(element.QualifiedName));
            }
        }

        /// <summary>
        /// Gets the paths to top level schemas in the specified XML file.
        /// </summary>
        /// <param name="targetXmlFile">The target XML file.</param>
        /// <returns>The list of distinct top-level schema paths.</returns>
        private static IEnumerable<string> GetTopLevelSchemaPaths(string targetXmlFile)
        {
            var doc = XDocument.Load(targetXmlFile);
            if (doc.Root == null) return null;

            var ns = XNamespace.Get("http://microsoft.com/dotnet/tools/xsd/");
            var elements = doc.Root.Elements(ns + "generateClasses");

            return
                elements.Elements(ns + "schema")
                    .Select(schema => schema.Value.ToLowerInvariant()).Distinct();
        }

        /// <summary>
        /// Loads the schema from the specified path and sets its SourceUri.
        /// </summary>
        /// <param name="schemaPath">The path to the schema to load.</param>
        /// <returns>The loaded schema.</returns>
        private static XmlSchema LoadSchema(string schemaPath)
        {
            using (var stream = File.OpenRead(schemaPath))
            {
                var schema = XmlSchema.Read(stream, null);
                schema.SourceUri = Path.GetFullPath(schemaPath).ToLowerInvariant();

                return schema;
            }
        }

        /// <summary>
        /// Loads the top level schemas from the specified XML file.
        /// </summary>
        /// <param name="targetXmlFile">The target XML file specifying the list of top-level schemas to process.</param>
        /// <returns>A collection of the loaded top-level schemas.</returns>
        private static XmlSchemas LoadTopLevelSchemas(string targetXmlFile)
        {
            var topLevelSchemas = new XmlSchemas();

            foreach (var schemaPath in GetTopLevelSchemaPaths(targetXmlFile))
            {
                topLevelSchemas.Add(LoadSchema(schemaPath));
            }

            return topLevelSchemas;
        }

        /// <summary>
        /// Gets a mapping from schema paths to loaded schemas.  This takes into account the supplied
        /// mapping from top-level schemas to included schemas that they are to be substituted for.
        /// </summary>
        /// <param name="topLevelSchemas">The top level schemas that have been loaded.</param>
        /// <param name="schemaSubstitutions">The schema substitutions.  The keys are top-level schemas.  The values are included schemas that the top-level schemas are to be substituted for.</param>
        /// <returns>A mapping from paths to loaded schemas.  The keys are paths to loaded top-level schemas and included schemas with a top-level schema substitute.  The values are the schema to use for that path.</returns>
        private static Dictionary<string, XmlSchema> GetLoadedSchemasWithSbustituations(IEnumerable<XmlSchema> topLevelSchemas, Dictionary<string, string> schemaSubstitutions)
        {
            // Make sure type mappings are case insensitive.
            schemaSubstitutions = new Dictionary<string, string>(schemaSubstitutions, StringComparer.InvariantCultureIgnoreCase);

            var loadedSchemas = new Dictionary<string, XmlSchema>();
            foreach (var topLevelSchema in topLevelSchemas)
            {
                loadedSchemas.Add(topLevelSchema.SourceUri, topLevelSchema);

                // If this top-level schema is a substitute for an included schema,
                // add a mapping from the included schema's path to the top-level schema
                string alias;
                if (schemaSubstitutions.TryGetValue(topLevelSchema.SourceUri, out alias))
                {
                    loadedSchemas.Add(alias.ToLowerInvariant(), topLevelSchema);
                }
            }

            return loadedSchemas;
        }


        /// <summary>
        /// Loads and compiles all schemas specified in the target XML file.
        /// </summary>
        /// <param name="targetXmlFile">The target XML file specifying the list of top-level schemas to process.</param>
        /// <param name="dataSchemaRootFolder">The root folder for the data schemas.</param>
        /// <param name="schemaSubstitutions">The schema substitutions.  The keys are top-level schemas.  The values are included schemas that the top-level schemas are to be substituted for.</param>
        /// <returns></returns>
        private static XmlSchemas LoadAndCompileAllSchemas(string targetXmlFile, string dataSchemaRootFolder, Dictionary<string, string> schemaSubstitutions)
        {
            XmlSchemas topLevelSchemas = LoadTopLevelSchemas(targetXmlFile);
            var loadedSchemas = GetLoadedSchemasWithSbustituations(topLevelSchemas, schemaSubstitutions);
            LoadIncludesFromAllSchemas(topLevelSchemas, dataSchemaRootFolder, loadedSchemas);

            topLevelSchemas.Compile(null, true);

            return topLevelSchemas;
        }

        /// <summary>
        /// Loads the includes from all schemas.
        /// </summary>
        /// <param name="topLevelSchemas">The top-level schemas.</param>
        /// <param name="dataSchemaRootFolder">The data schema root folder.</param>
        /// <param name="loadedSchemas">The mapping for schema paths to schemas that have already been loaded or have substitutes loaded.</param>
        private static void LoadIncludesFromAllSchemas(IEnumerable<XmlSchema> topLevelSchemas, string dataSchemaRootFolder, IDictionary<string, XmlSchema> loadedSchemas)
        {
            foreach (var topLevelSchema in topLevelSchemas)
            {
                LoadIncludesFromSchema(topLevelSchema, loadedSchemas, dataSchemaRootFolder);
            }
        }

        /// <summary>
        /// Gets the path to an included schema.
        /// </summary>
        /// <param name="externalSchema">The external schema.</param>
        /// <param name="parentSchema">The parent schema.</param>
        /// <param name="dataSchemaRootFolder">The data schema root folder.</param>
        /// <returns>The path to the included schema.</returns>
        private static string GetPathToExternalSchema(XmlSchemaExternal externalSchema, XmlSchemaObject parentSchema, string dataSchemaRootFolder)
        {
            if (string.IsNullOrEmpty(parentSchema.SourceUri))
                return string.Empty;

            var location = externalSchema.SchemaLocation;
            var parentSchemaFolder = Path.GetDirectoryName(parentSchema.SourceUri);
            if (string.IsNullOrEmpty(parentSchemaFolder))
                return string.Empty;

            var path = Path.Combine(parentSchemaFolder, location).ToLowerInvariant();

            if (!File.Exists(path))
                path = Path.Combine(dataSchemaRootFolder, location).ToLowerInvariant();

            return path;
        }

        /// <summary>
        /// Loads the includes from the specified parent schema.
        /// </summary>
        /// <param name="parentSchema">The parent schema.</param>
        /// <param name="loadedSchemas">The loaded schemas.</param>
        /// <param name="dataSchemaRootFolder">The data schema root folder.</param>
        private static void LoadIncludesFromSchema(XmlSchema parentSchema, IDictionary<string, XmlSchema> loadedSchemas, string dataSchemaRootFolder)
        {
            foreach (var include in parentSchema.Includes)
            {
                var externalSchema = include as XmlSchemaExternal;
                if (externalSchema == null || externalSchema is XmlSchemaImport || string.IsNullOrWhiteSpace(externalSchema.SchemaLocation))
                    continue;

                var path = GetPathToExternalSchema(externalSchema, parentSchema, dataSchemaRootFolder);

                XmlSchema includedSchema;
                if (!loadedSchemas.TryGetValue(path, out includedSchema) && File.Exists(path))
                {
                    includedSchema = LoadSchema(path);
                    loadedSchemas.Add(path, includedSchema);

                    LoadIncludesFromSchema(includedSchema, loadedSchemas, dataSchemaRootFolder);
                }

                externalSchema.Schema = includedSchema;
                externalSchema.SchemaLocation = null;
            }
        }

        private static void AddValidationAttributes(CodeNamespace codeNamespace, IEnumerable<XmlSchema> schemas, string standardFamily, string dataSchemaVersion, ICollection<string> dataObjects)
        {
            var types = new List<string>();

            foreach (var schemaElement in schemas.SelectMany(schema => schema.Elements.Values.Cast<XmlSchemaElement>().Where(x => x != null)))
            {
                AddValidationAttributes(codeNamespace, schemaElement, standardFamily, dataSchemaVersion, dataObjects, types);
            }
        }

        private static void AddValidationAttributes(CodeNamespace codeNamespace, XmlSchemaElement schemaElement, string standardFamily, string dataSchemaVersion, ICollection<string> dataObjects, ICollection<string> types)
        {
            var typeDeclaration = codeNamespace.Types.Cast<CodeTypeDeclaration>()
                .FirstOrDefault(x => x.Name == schemaElement.SchemaTypeName.Name);

            if (typeDeclaration == null || types.Contains(typeDeclaration.Name)) return;

            types.Add(typeDeclaration.Name);

            var schemaType = schemaElement.ElementSchemaType as XmlSchemaComplexType;
            if (schemaType == null) return;

            if (dataObjects.Contains(typeDeclaration.Name))
                AddEnergisticsDataObjectAttribute(typeDeclaration, standardFamily, dataSchemaVersion);

            foreach (var attribute in schemaType.AttributeUses.Values.OfType<XmlSchemaAttribute>())
            {
                AddAttributeValidation(typeDeclaration, attribute);
            }

            var schemaSequence = schemaType.ContentTypeParticle as XmlSchemaSequence;
            if (schemaSequence == null) return;

            var elements = schemaSequence.Items.OfType<XmlSchemaSequence>()
                .SelectMany(x => x.Items.OfType<XmlSchemaElement>())
                .Union(schemaSequence.Items.OfType<XmlSchemaElement>());

            foreach (var element in elements)
            {
                AddElementValidation(codeNamespace, typeDeclaration, element);

                AddValidationAttributes(codeNamespace, element, standardFamily, dataSchemaVersion, dataObjects, types);
            }
        }

        private static void AddEnergisticsDataObjectAttribute(CodeTypeMember typeDeclaration, string standardFamily, string dataSchemaVersion)
        {
            typeDeclaration.CustomAttributes.Add(new CodeAttributeDeclaration(typeof(EnergisticsDataObjectAttribute).FullName,
                new CodeAttributeArgument(new CodePrimitiveExpression(standardFamily)), new CodeAttributeArgument(new CodePrimitiveExpression(dataSchemaVersion))));
        }

        private static void AddAttributeValidation(CodeTypeDeclaration typeDeclaration, XmlSchemaAttribute attribute)
        {
            var memberProperty = GetMemberProperty(typeDeclaration, attribute.Name);

            if (memberProperty != null)
            {
                AddDescriptionAttribute(memberProperty, GetAnnotation(attribute));
            }
        }

        private static void AddElementValidation(CodeNamespace codeNamespace, CodeTypeDeclaration typeDeclaration, XmlSchemaElement element)
        {
            var memberProperty = GetMemberProperty(typeDeclaration, element.Name);
            var restrictions = GetElementRestrictions(element).ToList();

            if (memberProperty == null) return;

            if (element.MinOccurs > 0)
            {
                AddRequiredAttribute(memberProperty);
            }

            if (restrictions.Any())
            {
                if (memberProperty.Type.ArrayElementType == null)
                {
                    AddValidationAttributes(typeDeclaration, memberProperty, restrictions);
                }
                else
                {
                    var baseTypeDeclaration = codeNamespace.Types.Cast<CodeTypeDeclaration>()
                        .FirstOrDefault(x => x.Name == memberProperty.Type.BaseType);

                    var xmlTextProperty = baseTypeDeclaration?.Members.OfType<CodeMemberProperty>().FirstOrDefault(Has<XmlTextAttribute>);

                    if (xmlTextProperty != null)
                    {
                        AddValidationAttributes(baseTypeDeclaration, xmlTextProperty, restrictions);
                    }
                }
            }

            AddDescriptionAttribute(memberProperty, GetAnnotation(element));
        }

        private static void AddRequiredAttribute(CodeTypeMember memberProperty)
        {
            memberProperty.CustomAttributes.Add(new CodeAttributeDeclaration(typeof(RequiredAttribute).FullName));
        }

        private static void AddValidationAttributes(CodeTypeDeclaration typeDeclaration, CodeMemberProperty memberProperty, IList<XmlSchemaFacet> facets)
        {
            var pattern = facets.OfType<XmlSchemaPatternFacet>().FirstOrDefault();

            var maxLength = facets.OfType<XmlSchemaMaxLengthFacet>().FirstOrDefault();

            var minInclusive = facets.OfType<XmlSchemaMinInclusiveFacet>().FirstOrDefault();
            var maxInclusive = facets.OfType<XmlSchemaMaxInclusiveFacet>().FirstOrDefault();

            if (pattern != null)
            {
                if (memberProperty.Type.BaseType == typeof(string).FullName && !Has<RegularExpressionAttribute>(memberProperty))
                {
                    memberProperty.CustomAttributes.Add(new CodeAttributeDeclaration(typeof(RegularExpressionAttribute).FullName,
                        new CodeAttributeArgument(new CodePrimitiveExpression(pattern.Value))));
                }
                else if (memberProperty.Type.BaseType == typeof(DateTime).FullName && pattern.Value != ".+")
                {
                    if (UseCustomTimestamp)
                    {
                        var memberField = GetMemberField(typeDeclaration, memberProperty.Name + "Field");
                        memberField.Type = new CodeTypeReference("Energistics.SchemaGatherer.Timestamp");
                        memberProperty.Type = memberField.Type;
                    }
                }
            }

            if (maxLength != null && memberProperty.Type.BaseType == typeof(string).FullName && !Has<StringLengthAttribute>(memberProperty))
            {
                memberProperty.CustomAttributes.Add(new CodeAttributeDeclaration(typeof(StringLengthAttribute).FullName,
                    new CodeAttributeArgument(new CodePrimitiveExpression(int.Parse(maxLength.Value)))));
            }

            if (minInclusive != null && maxInclusive != null && !Has<RangeAttribute>(memberProperty))
            {
                memberProperty.CustomAttributes.Add(new CodeAttributeDeclaration(typeof(RangeAttribute).FullName,
                    new CodeAttributeArgument(new CodePrimitiveExpression(double.Parse(minInclusive.Value))),
                    new CodeAttributeArgument(new CodePrimitiveExpression(double.Parse(maxInclusive.Value)))));
            }
        }

        private static void AddDescriptionAttribute(CodeMemberProperty memberProperty, string description)
        {
            if (string.IsNullOrEmpty(description) || Has<DescriptionAttribute>(memberProperty)) return;

            memberProperty.CustomAttributes.Add(new CodeAttributeDeclaration(typeof(DescriptionAttribute).FullName,
                new CodeAttributeArgument(new CodePrimitiveExpression(description))));

            memberProperty.Comments.Add(new CodeCommentStatement("<summary>" + description + "</summary>", true));
        }

        private static bool Has<T>(CodeMemberProperty memberProperty)
        {
            return memberProperty.CustomAttributes
                .OfType<CodeAttributeDeclaration>()
                .Any(x => x.Name == typeof(T).FullName);
        }

        private static CodeMemberProperty GetMemberProperty(CodeTypeDeclaration typeDeclaration, string propertyName)
        {
            return typeDeclaration.Members.OfType<CodeMemberProperty>()
                .FirstOrDefault(x => x.Name == propertyName);
        }

        private static CodeMemberField GetMemberField(CodeTypeDeclaration typeDeclaration, string propertyName)
        {
            return typeDeclaration.Members.OfType<CodeMemberField>()
                .FirstOrDefault(x => x.Name == propertyName);
        }

        private static IEnumerable<XmlSchemaFacet> GetElementRestrictions(XmlSchemaElement schemaElement)
        {
            var facets = new List<XmlSchemaFacet>();

            GetElementTypeRestrictions(facets, schemaElement.ElementSchemaType as XmlSchemaSimpleType);

            var complexType = schemaElement.ElementSchemaType as XmlSchemaComplexType;
            if (complexType != null)
            {
                GetElementTypeRestrictions(facets, complexType.BaseXmlSchemaType as XmlSchemaSimpleType);
            }

            return facets;
        }

        private static void GetElementTypeRestrictions(ICollection<XmlSchemaFacet> facets, XmlSchemaSimpleType elementType)
        {
            while (elementType != null)
            {
                var restrictions = elementType.Content as XmlSchemaSimpleTypeRestriction;

                if (restrictions != null)
                {
                    foreach (var facet in restrictions.Facets.OfType<XmlSchemaFacet>().Where(facet => facets.All(x => x.GetType() != facet.GetType())))
                    {
                        facets.Add(facet);
                    }
                }

                elementType = elementType.BaseXmlSchemaType as XmlSchemaSimpleType;
            }
        }

        private static string GetAnnotation(XmlSchemaAnnotated annotated)
        {
            var description = string.Empty;

            if (annotated.Annotation != null)
            {
                description = annotated.Annotation.Items
                    .OfType<XmlSchemaDocumentation>()
                    .SelectMany(x => x.Markup)
                    .Select(x => x.InnerText
                        .Replace(Environment.NewLine, " ")
                        .Replace("\n", " ")
                        .Replace("\t", string.Empty)
                        .Trim())
                    .FirstOrDefault();
            }

            return description;
        }
    }
}
